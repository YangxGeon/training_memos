# DAY1
강사 정보
---
- 최국현
- tang/앙/linux.com

__점심시간:__ 01시 20분부터 02시 20분까지

__쉬는시간:__ 약 10분~15분

- [리눅스 깃헙/메모/교재 주소](https://github.com/tangt64/training_memos/tree/main/opensource/linux-101)
- [메모 주소](https://github.com/tangt64/training_memos/blob/main/opensource/linux-101/20230710-memo.md)
- [판서 주소](https://wbd.ms/share/v2/aHR0cHM6Ly93aGl0ZWJvYXJkLm1pY3Jvc29mdC5jb20vYXBpL3YxLjAvd2hpdGVib2FyZHMvcmVkZWVtL2UzZTI5MjAxMTNlMTQ5Zjg4OTJhMjgyMGU5NmFkMWI2X0JCQTcxNzYyLTEyRTAtNDJFMS1CMzI0LTVCMTMxRjQyNEUzRF9hYmU1ODI4Yi0zZWQ0LTRmNGEtODVkYi1iYWNiZGE3MTQ1ZDE=)



1. 강의 진행 시 필요한 소프트웨어는 가상화 소프트웨어 및 리눅스 ISO이미지 입니다. 
2. 하이퍼바이저는 윈도우 10/11 Pro기준으로 하이퍼브이 사용합니다.
3. 이번 강의는 교재를 별도로 사용하지 않습니다.
4. 기본적인 리눅스 운영 및 사용 경험이 요구가 되는 과정 입니다.


- 센트OS 8 스트림(권장하지 않음)
- [센트OS 9 스트림](https://www.centos.org/download/)
- [로키 9](https://rockylinux.org/news/rocky-linux-9-0-ga-release/)
  + https://mirror.navercorp.com/rocky/9.2/isos/x86_64/Rocky-9-latest-x86_64-minimal.iso


## 랩 환경

1. 하이퍼브이 기반으로 진행
2. Windows 10/11 Pro 버전(가상화 가속 기능)
3. 리눅스 호스트 기반으로 사용 가능(libvirt기반으로 랩 가능)
  - 버추얼박스, 권장하지 않음(vCPU 문제. 특히 AMD CPU에서 문제가 있음)
  - AMD CPU사용하시면, 가상화 솔루션 버전별로 오동작이 발생할수 있음
4. VMWare Workstation/Player(교육용 라이선스가 불가능)
6. CentOS-9-Stream, Rocky 9

노트북/데스크탑(워크스테이션)
---
CPU: 4 cores(VMware Workstation, VirtualBox, Hyver-V)
MEM: 8GiB

__가상머신:__ vCPU: 1, vMEM: 2GiB, vDisk 30GiB x 3

__가상머신 갯수:__ 최소 1대이상. 권장은 2대.


## 오늘의 목표!!

- [X] systemd
  + [X] journalctl(journald)
  + [X] ramdisk(dracut, systemctl daemon-reload)
  + [X] .ntp, .timer == cron, chronyd
- [ ] container
- [ ] disk(LVM2/vdo/stratis)
- [ ] firewalld
- [ ] Network


### systemd

기존에 사용하던, systemV, Up-Start를 대체하는게 주요 목적. 이전 리눅스 배포판에 제일 큰 문제는 서비스와 시스템 영역 구별이 불확실함.

```bash
service httpd start
/etc/init.d/httpd start
```

시스템 블록이 __systemd__ 로 통합하면서, 변경된 부분은 다음과 같음.

1. 커널 및 시스템 블록의 통합(램 디스크)
2. 시스템 유닛 관리명령어 통합(systemctl, timedatectl, localectl, hostnamectl...)
3. 스크립트 최소화(Unit INI based)
4. ntp(chrony), crontab, network와 같은 자원도 systemd로 통합 중
5. 이전에 사용하였던 네트워크 스크립트는 RHEL기준 8이후로 더 이상 지원하지 않음


공통사항
---
systemd에서 사용하는 모든 유닛의 파일 사양은 INI형태로 구성이 되어 있음.


- __.target:__ System-V에서 런레벨로 사용했던 기능. 다른 기능은 여러 서비스의 묶을 관리하는 역할.

- __.service:__ 애플리케이션 패키지가 설치가 되면, 일반적으로 제공되는 서비스 관리 파일. 이전에는 __init__ 에서 사용하던 스크립트가 서비스 파일로 변경


```bash
## Runlevel 3: multi-user.target
## Runlevel 5: graphical.target 

## 만약, 런레벨(타겟) 변경을 테스트 하고 싶으시면 아래 환경 패키지 설치

dnf groupinstall "Server with GUI" -y 

systemctl get-default
systemctl set-default graphical.target

systemctl isolate graphical.target
                  multi-user.target

dnf install httpd -y

systemctl start httpd.service
          edit  <--> 유닛 INI편집,       ## "drop-in"파일 이라고 부름
          restart
          stop  
          reload                        ## 모든 서비스 파일에서 사용이 가능하지 않음.
          status                        ## cgroup를 통해서 systemd밑에서 동작하는 모든 유닛의 자원 상태 추적 및 모니터링
          is-active  <--> start <--> status
          
          is-failed
          enable <--> is-enabled        ## systemctl enable --now <SERVICE>
          disable                       ## 서비스 부트업 취소
          mask                          ## 서비스 비활성화
```

```bash
           .--> systemd-journald     ## rsyslogd대체 서비스.
          /
          ------
systemctl status <SERVICE>           ## .service with .slice와 함께 동작.
          ------
          \
           `--> CGROUP    ## 초창기 컨테이너 기술, 구글에서 만듦.
                ------
                # systemd-cgls
                # systemd-cgtop
                # journalctl -u <SERVICE> -fl

init 3 --> telinit 3 <-- systemctl isolate
init 5 --> telinit 5 <-- systemctl isolate
cat /etc/inittab
````

## journald/journalctl

systemd-journald에서 모든 시스템의 표준 출력 및 오류 메세지를 자동으로 로깅 및 분류(바이너리 디비 기반).

메세지 우선순위는 syslog에서 정의된 기준으로 사용이 가능.

```bash
man 1 journalctl
man 3 syslog
> "emerg" (0), "alert" (1), "crit" (2), "err" (3), "warning" (4), "notice" (5), "info" (6), "debug" (7)
> 8진수(otact)
```


```bash
tail -f /var/log/message  <--> journalctl -fl     ## 시스템에서 동작중인 애플리케이션 표준 출력 및 오류 로그 내용
tail -f /var/log/httpd/error.log & <--> journalctl -u httpd -perr -pwarning
tail -f /var/log/httpd/access.log &
dmesg    <-->   journalctl -b              ## ramdisk로깅 포함
                journalctl -k              ## 커널 로깅만 출력
```

영구적으로 __systemd-journald__ 에 기록을 남기기 위해서 아래와 같이 조정.

```bash
## 첫번째 방법(이지)

ls -l /run/log/journal/<UUID>            
cp -a /run/log/journal/ /var/log/
systemctl status systemd-journald
>/run/log/journal/
systemctl restart systemd-journald
reboot
systemctl status systemd-journald
>/run/log/journal/
>/var/log/journal/

## 두번째 방법(뇌 사용 요구)

vi /etc/systemd/journald.conf
[Journal]
Storage=persistent    ## Storage=auto
systemctl restart systemd-journald       ## killall -USR1 systemd-journald
```
### systemd의 귀찮은 부분

커널 및 커널 모듈, 그리고 블록 장치가 변경이 되는 경우, 무조건 램 디스크를 갱신.

```bash
systemctl daemon-reload    ## systemd에 리부팅시 램 디스크 갱신 요청
```

systemd 램 디스크 갱신 조건은 대략 다음과 같다.

1. /etc/fstab
2. 커널 업데이트
3. 모듈 추가 및 갱신
4. systemd관련 내용 변경 및 수정

__"dracut -f"__ 명령어로 강제로 램 디스크 갱신 권장. 대신, 온라인(가동중인) 시스템에서는 가급적이면 사용하지 말것. 리부팅 계획이 있을때, 해당 명령어 사용 권장.


### .timer, .ntp, chrony, cron


#### .timer

모든 사용자 확장 서비스는 아래 위치에서 생성한다.

__/etc/systemd/system/

```bash
vi myMonitor.service
```
```INI
[Unit]
Description=Logs system statistics to the systemd journal
Wants=myMonitor.timer

[Service]
Type=oneshot
ExecStart=/usr/bin/free

[Install]
WantedBy=multi-user.target
```

```bash
systemctl status myMonitor.service
systemctl enable --now myMonitor.service
systemctl status myMonitor.service
```

```bash
vi /etc/system/system/myMonitor.timer
```
```INI
[Unit]
Description=Logs some system statistics to the systemd journal
Requires=myMonitor.service

[Timer]
Unit=myMonitor.service
OnCalendar=*-*-* *:*:00

[Install]
WantedBy=timers.target
```
```bash
systemctl enable --now myMonitor.timer
```

#### cron

현 대다수 리눅스 시스템(systemd기반)에서 사용하는 작업 예약.

- anacron(cron)
- at
- systemd timer

위의 3가지가 대표적인 시스템 작업예약. 'at'는 거의 사용하지 않음.

```bash
crontab -l                    ## /var/spool/cron/<USERNAME>
crontab -l -u <USERNAME>      ## 예약된 작업 출력
crontab -e -u <USERNAME>      ## 사용자 작업 예약

adduser cronuser1
adduser cronuser2        ## echo "I hate systemd", 매 1분마다 출력
                         ## journalctl로 확인

crontab -e -u cronuser1
> */10 * * * * echo "Hello World"    
cat /var/spool/cron/cronuser1
> */10 * * * * echo "Hello World"    
crontab -l -u cronuser1
> */10 * * * * echo "Hello World"    

```

journalctl에서 확인이 필요한 경우 아래 명령어 실행.

```bash
journalctl _COMM=crontab _COMM=crond -lf  
```
##### chronyd

현재 NTP프로토콜을 지원하는 프로그램은 아래와 같음.(서버/클라이언트 포함)

1. ntpd
2. chronyd
3. system-timesyncd

__"ntpd"__ 서비스는 꽤 오래된 서비스 및 프로그램. 현재, 대다수 리눅스 배포판은 "ntpd"를 사용하지 않음. 

__"chronyd"__ 기존 "ntpd"서비스를 대체하는 프로그램. 효율적이고 적은 리소스를 소모. ntpd에 비해서 동작이 빠르다. 

대다수 ntpd, chronyd 두 개의 서비스는 __서버/클라이언트__ 기능을 가지고 있음. 클라이언트 설정 혹은 로컬에서 사용하는 경우, __"systemd-timesyncd"__ 로 구성을 권장.

```bash
vi cat /etc/chrony.conf
pool 2.rocky.pool.ntp.org iburst                ## iburst동기화가 가능할때 최대한 빠르게 동기화.
server 192.168.90.250 iburst
server 1.kr.pool.ntp.org burst                  ## 이 옵션은 권장하지 않음

systemctl restart chronyd

timedatectl 
chronyc sources
> ec2-13-209-84-50.ap-nort>     2   6    17    19    -26ms[  -31ms] +/-   39ms  
```

#### systemd-timesyncd

```bash
dnf search systemd-timesyncd
dnf install epel-release -y
dnf install systemd-timesyncd -y

mkdir -p /etc/systemd/timesyncd.conf.d/
vi /etc/systemd/timesyncd.conf.d/local.conf

setenforce 0
systemctl enable --now systemd-timesyncd          ## chronyd서비스는 자동으로 중지

timedatectl timesync-status
timedatectl show-timesync 
```
```INI
NTP=1.kr.pool.ntp.org                       ## 동기화 대상 NTP 서버 목록
FallbackNTP=3.asia.pool.ntp.org             ## 실패시 시도할 NTP 서버 목록
```

연습문제
---

1. 아래와 같이 사용자를 생성 후, "free -m", "df -h" 명령어가 매 5분마다 실행이 되도록 한다.
  + 사용자 이름은 "monitor-mem".
    * 해당 사용자는 "free"명령어 실행.
  + 사용자 이름은 "monitor-disk".
    * 해당 사용자는 "df"명령어 실행.

2. 아래 패키지를 설치 후, 서비스를 시작 및 부트업 활성화.
  + vsftpd 패키지 설치.
  + 이 서비스는 시작 및 부트업이 되어야 한다.

3. NTP기반의 클라이언트 서비스를 구성한다.
  + NTP서버의 주소는 "ntp-wwv.nist.gov".
  + 해당 서버와 최대한 빠르게 동기화 한다.
  + timedatectl, chronyc명령어로 동기화가 올바르게 되었는지 확인한다.
  

## container


```bash
dnf search podman
dnf install podman -y 
# systemctl start docker
# systemctl status podman, API서비스용도.
podman container ls                               ## podman ps
podman pod ls
podman pull docker.io/library/centos              ## CentOS 이미지
podman pull docker.io/library/nginx               ## Nginx 이미지
podman images

podman run -d  --name test-centos --rm docker.io/library/centos sleep 100000
## -d, daemonized 백그라운드로 프로세스 실행
## --rm, 만약, 컨테이너 프로세스가 종료가 되면 제거
podman container ls
podman exec -it test-centos /bin/bash
> [root@ba79f32769b5 /]# df 
> [root@ba79f32769b5 /]# ip a 
> eth0@if4                                           ## 네임스페이스 영역 네트워크
> [root@ba79f32769b5 /]# cd /dev/
> [root@ba79f32769b5 /]# ls -l
> [root@ba79f32769b5 /]# ps -ef
> root           1       0  0 08:03 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/b                ## 네임스페이스 영역 프로세스
> exit
ip netns
> netns-8ed179ba-f973-9cb8-5f96-ca37c1328fce (id: 0)
ip netns exec netns-8ed179ba-f973-9cb8-5f96-ca37c1328fce ip a s eth0
```

### what the namespace??

```bash
lsns
> 4026532131 net         1  7229 
cd /proc/7229/ns
ls -l

```


```
cd ~
mkdir ~/htdocs
echo "Hello World" > htdocs/index.html
podman run -d --rm --name nginx -p 8080:80 -v /root/htdocs:/usr/share/nginx/html docker.io/library/nginx
curl localhost:8080
```