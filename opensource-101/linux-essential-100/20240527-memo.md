# 리눅스 어드민 기본 과정

가상서버 2대 기반으로 랩을 진행 합니다.

## 랩에서 사용하는 가상머신 사양
* ISO 내려받기 주소[링크](https://download.rockylinux.org/pub/rocky/9/isos/x86_64/Rocky-9.3-x86_64-minimal.iso)
* 하이퍼브이[링크](https://learn.microsoft.com/ko-kr/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v)
  - windows 10/11 pro
* VirtualBox, VMware Player/Workstation
  - AMD CPU에서는 비권장(특히, VBox)
  - Fusion, VMware Player

## 강의실 정책
- 쉬는시간: 매 시간 50분 수업 후 15분 휴식
- 점심시간: 11시 40분 ~ 12시 50분(1시간 20분, 실제시작은 보통 1시)


```bash
vCPU: 2개(I3,I5), 사양이 부족하시면 1개로도 가능
vMEM: 2048MiB+ 
vDISK: 
  Node 1: OS=20GiB
          /dev/vda: OS, 20GiB  ## 따라오기 어려우시면, 일단 OS만 설치!!
          /dev/vdb: data, 2GiB
          /dev/vdc: data, 2GiB
          /dev/vdd: data, 3GiB
          HOSTNAME: node1.example.com
  Node 2: OS=20GiB
          /dev/vda: OS, 20GiB
          /dev/vdb: data, 2GiB
          /dev/vdc: data, 2GiB
          /dev/vdd: data, 3GiB          
          HOSTNAME: node2.example.com
```

# DAY 1

## 사용자 관리

### 사용자 비밀번호

1. adduser, GNU계열의 사용자 추가 명령어
2. useradd, BSD계열의 사용자 추가 명령어

```bash
whereis adduser(default)
whereis useradd(link, symbolic)
```

### 새로 추가된 옵션(systemd, btrfs, selinux)
---
1. --badname: 사용자 이름 형식 확인하지 않음.
2. --btrfs-subvolume-home: 사용자 홈 디렉터리를 서브볼륨의 구성.(레드햇 계열에서 사용 불가능)
3. --password: 사용자 패스워드 설정. 대신, openssl, mkpasswd를 통해서 사용이 가능. 
4. --root: chroot기능. 사용자를 가상의 네임스페이스 영역(컨테이너)에서 사용이 가능.

"2", "3", "4"번은 앞으로 많이 사용할 옵션.

```bash
                         groupmod
                   .---> usermod
                  /
             /etc/group
adduser ---> /etc/passwd <--- [systemd] --- <logind>
            ------------
              \
               `---> /etc/gshadow
                     /etc/shadow

getent ---> /etc/passwd
          > /etc/group
          > /etc/hosts

```

### 사용자 추가

```bash
## 1
adduser testuser0
passwd testuser0

## 2
adduser testuser1
passwd testuser1
echo rocky | passwd --stdin testuser1

## 3
dnf provides mkpasswd 
> mkpasswd
dnf install mkpasswd -y
mkpasswd -m sha-512
adduser testuser2 --password $6$U9eL0Hyz2aQQPkg6$7svxabfdis20VFAorDh99uTwqa.EjblifybBrYukqjUXC7AaoVLKsceVtSgMd7Dx1eIuHYIhJIJQ.HsktTq651
```

### 사용자 생성 확인

사용자 비밀번호를 콘솔에서 입력 후 접근하기 위해서 "sshpass"패키지 설치를 권장.

```bash
su - <USER>                                                     ## 비밀번호 없이 사용자 전환이 가능. 비밀번호 확인이 불가능.
ssh user1@node1.example.com                                     ## 비밀번호 입력 후 로그인이 되어야함.
> <PASSWORD>

dnf install sshpass -y
ssh testuser[1-2]@localhost
sshpass -p rocky ssh testuser1@localhost id
> uid=1001(testuser2) gid=1001(testuser2)
ssh user1@localhost
sshpass -p rocky ssh testuser2@localhost id
> uid=1001(testuser2) gid=1001(testuser2)
```


### 그룹 생성 및 사용자 추가

사용자 그룹 생성 시 사용하는 명령어는 아래와 같다.
- groupadd
- usermod
- groupmod

특정 사용자를, 특정 그룹에 편입 시키는 방법.
- 사용자 UID 그룹 GID 1000번으로 시작(systemd이후로 모든 리눅스는 1000번 이후로 사용)
- 일반적으로 그룹만 시스템에 추가하는 경우 GID를 1만번(10000) 이후부터 사용

```bash
/etc/passwd
0
  
499     > system account: kernel 
          service account: httpd, ftpd

999

1000    > normal user account

/etc/group
10000   > group GID additional range

```

```bash
groupadd testgroup -g 10000
usermod -aG testgroup testuser1
usermod -aG testgroup testuser2

grep testgroup /etc/group 
> testgroup:x:1003:testuser1,testuser2
  ---------        -------------------
  그룹이름               사용자들

groups testuser1
> testuser1 : testuser1 testgroup
              --------- ---------
              주 그룹    보조 그룹
```

### 사용자 확인

리눅스 사용자 확인을 위해서 보통 사용하는 방식이 'id', 'grep testuser1 /etc/passwd'와 같은 방법으로 한다.
앞으로 사용할 __표준 리눅스(LSB Linux)__ 에서는 다음과 같은 방식(getent)으로 사용자 확인을 권장.

```bash
getent
> Get entries from administrative database(/etc/passwd, /etc/group).
> 사용자 정보를 가져오는 명령어.

getent passwd testuser1
> testuser1:x:1002:1002::/home/testuser1:/bin/csh
getent group testgroup
             testuser1
> testgroup:x:1003:testuser1,testuser2
getent host node1.example.com
```

### 쉘 변경

1. usermod(default)
2. chsh(optional package)

```bash
dnf provides chsh
> util-linux-user
dnf install util-linux-user -y
dnf install zsh csh -y

## 쉘 정보를 확인하고 싶은 경우
chsh -l
> /bin/sh
> /bin/bash
> /usr/bin/sh
> /usr/bin/bash
> /usr/bin/zsh
> /bin/zsh
> /bin/csh

chsh -s /bin/zsh testuser2
usermod -s /bin/zsh testuser2
getent passwd testuser2
> testuser2:x:1001:1001::/home/testuser2:/bin/zsh
```

### 사용자 락(lock) 혹은 로그인 금지

특정 사용자가 더 이상 시스템에 로그인을 할 수 없도록 하는 요구사항.

1. 'usermod', 'chsh'로 쉘을 변경.(아내 메세지가 출력이 됨)
2. 'usermod -L'명령어로 사용자 잠금.(안내 메세지가 출력이 되지 않음)

보통 리눅스에서 로그인이 되지 않는 쉘은 다음처럼 구성 및 사용.

1. /usr/bin/false
2. /usr/sbin/nologin(default, 쉘 안내 메세지가 출력)

```bash
## 사용자를 로그인을 하지 못하도록 한다.
usermod -s /usr/sbin/nologin noshelluser
~~usermod -s /usr/sbin/false noshelluser~~
sshpass -p rocky ssh noshelluser@localhost
> This account is currently not available.
> Connection to localhost closed.


## 특정 사용자는 시스템 접근이 되지 않는다.
usermod -L baduser
getent passwd baduser

sshpass -procky ssh baduser@localhost
> Permission denied, please try again.
```

### 연습문제 1

예를 들어서 다음과 같이 사용자 및 그룹 구성.

|그룹이름  |사용자 이름 |ID값       |
|---------|------------|-----------|
| sharegrp|user1,user2 |GID: 10000 | 
| datagrp |            |GID: 11000 |
| devel   |user3       |           |
| infra   |user4       |           |
| cloud   |user5       |           |



```bash
## 먼저 그룹 생성 후 사용자 추가
chsh -l                                                  ## 쉘 목록 확인이 가능
cat /etc/shells                                          ## 쉘 목록 확인이 가능
usermod                                                  ## 계정 정보 변경

groupadd sharegrp -g 10000                               ## -g옵션을 통해서 사용자 그룹 gid값을 변경
groupadd datagrp -g 11000

adduser -u 10000 -G sharegrp -s /usr/bin/tcsh user1      ## UID + GID + SHELL 사용자 생성 
adduser -u 11000 -G datagrp  -s /usr/bin/nologin user2

echo "helloworld" | passwd --stdin user1                 ## 패스워드 설정
echo "helloworld" | passwd --stdin user2                 ## 패스워드 설정

id user1                                                 ## 사용자가 잘 추가가 되었는지 확인
id user2

adduser -G sharegrp user1
adduser -G sharegrp user2
cat /etc/group

## 사용자 추가 후, 그룹 설정

groupadd sharegrp -g 10000
tail -10 /etc/group

id user1

usermod -aG

# a: append
# G: GroupName

usermod -aG sharegrp user1
usermod -aG sharegrp user2
usermod -aG devel user3
usermod -aG infra user4
usermod -aG cloud user5

id user1
id user2
id user3
id user4
id user5
```

### 연습문제 2

랩에서 생성할 사용자 이름.
  - user1, bash
  - user2, 쉘 사용 금지 혹은 로그인 불가능 == nologin
  - user3, csh 
  - user4, tcsh
  - user5, fish

```bash
adduser user1
adduser -s /usr/sbin/nologin user2
adduser -s /usr/bin/csh user3
adduser -s /usr/bin/tcsh user4
adduser -s /usr/bin/fish user5
```

사용자 hacker는 csh를 사용한다.
사용자 twitter는 쉘 접근이 되지 않으며, sharegrp에 보조 그룹으로 가입이 되어있다.
모든 사용자 비밀번호는 명시되어 있는 비밀번호로 설정한다.


일반 사용자에게 쉘 권한을 비부여 하려면 아래와 같이 쉘 설정
  - 사용자가 추가가 되면, 보통은 /etc/passwd에 사용자가 추가
  - RHEL 7/8/9오면서 기본적으로 모든 사용자는 UID/GID 1000:1000으로 시작함

```bash
##
## 무조건 루트에서 작업
##

cat /etc/shells                  ## 모든 쉘 경로가 있음, nologin, false는 없음.

dnf install epel-release -y      ## fish설치하기 위해서 엔터프라이즈 패키지 저장소 설치
dnf install csh fish -y
cat /etc/passwd
adduser user1
echo $?                          ## 명령어 실행값 반환 확인. 0으로 반환이면 문제가 없음.
grep user1 /etc/passwd
adduser -s <SHELL_PATH>          ## chsh -l
adduser -s /usr/sbin/nologin
                                 ## cat /etc/shells
whereis false                    ## 로그인 차단
whereis nologin                  ## 로그인 차단, 권장
dnf install util-linux-user -y
chsh -l
chsh -s /usr/sbin/nologin user3
usermod -s <SHELL> user3         ## LSB(Linux Standard base)에서 권장
vi /etc/passwd
user3:x:1002:1002::/home/user3:/usr/bin/tcsh

userdel -r user3                 ## -r home디렉터리 삭제
userdel -r user2  
userdel user1                    ## rm -rf /home/user1
```
만약 "Creating mailbox file: File exists"메일 박스 오류가 발생하는 경우.
```bash
userdel user1
adduser user1
Creating mailbox file: File exists
rm -f /var/spool/mail/user1
```

### 사용자 정보 수정

1. 사용자 제거

```bash
adduser incorrectuser
userdel -r incorrectuser

getent passwd incorrectuser

echo $?         ## 0: 정상, 1: 비정상
```

2. 사용자 정보 수정

```bash
usermod -u 15000 incorrectuser
getent passwd incorrectuser
> 15000
groupmod -g 15000 incorrectuser
> 15000
usermod --login correctuser incorrectuser
usermod --login correctuser --move-home /home/correctuser incorrectuser 
groupmod --new-name corretuser incorrectuse
mkdir -p /home/correctuser 
usermod --home /home/correctuser correctuser
getent passwd correctuser
> correctuser:x:150000:150000::/home/correctuser:/bin/bash
```

## DNF3/YUM

### dnf, yum 차이점
RHEL 8버전 이후부터는 yum명령어에서 RHEL 9부터는 dnf명령어로 세대 교체가 됨. 
dnf에서는 추가적으로 __module__ 기능을 지원하며, yum에 비해서 실행속도 및 메모리 사용량이 작고 빠름.

명령어 위치 확인.
```bash
whereis dnf
whereis yum
```

1. 저장소 관련(RHEL vs CentOS vs Rocky)

- appstream                                              Rocky Linux 9 - AppStream
- baseos                                                 Rocky Linux 9 - BaseOS
- extras                                                 Rocky Linux 9 - Extras

"appstream"에서 추가된 패키지는 앞서 이야기한 "module package"가 추가가 됨.
```bash
dnf module list
> nginx[1.22]
> nginx[1.24]

dnf info nginx
> 1.20
dnf module install nginx:1.24
```

2. 변경된 명령어 도구(yum-utils)

- yum-config-manager: yum-utils
- dnf config-manager: dnf command(default) 

```bash
rm -f /etc/yum.repos.d/*
ls -l /etc/yum.repos.d/
> N/A 

## 1번
dnf config-manager --add-repo=http://localhost/rpms

## 2번 
dnf install yum-utils
yum-config-manager --add-repo=http://localhost/rpms
> /etc/yum.repos.d/localhost.repo

dnf clean all
dnf search httpd-core

## SELinux에 차단중
setenforce 0 

vi /etc/yum.repos.d/localhost.repo
> [localhost]
> name=created by dnf config-manager from http://localhost
> baseurl=http://localhost
> enabled=1
> gpgcheck=0
dnf install vsftpd -y
```

3. 저장소 구성

```bash
dnf install yum-utils -y
vi ~/.tmux.conf
> set-option -g mouse on
> bind -n WheelUpPane if-shell -F -t = "#{mouse_any_flag}" "send-keys -M" "if -Ft= '#{pane_in_mode}' 'send-keys -M' 'select-pane -t=; copy-mode -e; send-keys -M'"
> bind -n WheelDownPane select-pane -t= \; send-keys -M
tmux
dnf install httpd httpd-core -y
mkdir -p /var/www/html/rpms
rm -f /etc/yum.repos.d/localhost.repo
dnf reposync -p /var/www/html/rpms
dnf install createrepo_c -y
createrepo_c /var/www/html/rpms
systemctl enable --now httpd
```

### 상규님 질문 :)

여러 버전의 RPM파일을 오프라인으로 저장소 형태로 만들고 싶은 경우(dnf기준) 다음과 같이 진행.

```bash
mkdir -p /var/www/html/rpms/9.0
reposync --releasever 9.0 -p /var/www/html/rpms/9.0/
createrepo /var/www/html/rpms/9.0/
mkdir -p /var/www/html/rpms/9.1
reposync --releasever 9.1 -p /var/www/html/rpms/9.1/
createrepo /var/www/html/rpms/9.1/
```


3. 패키지 관리

1. RPM명령어(rpm)

이 명령어는 오프라인 상태에서 사용이 가능. 저장소 없이 사용 가능.
```bash
rpm -qi httpd-core         ## 패키지 정보
rpm -ql httpd-core         ## 파일 목록
rpm -qf /usr/sbin/httpd == dnf provides httpd
rpm -qa httpd
rpm -qa | grep httpd 
rpm -e httpd-core
```

2. dnf/yum 

이 명령어는 오프라인에서 동작하지 않음. disconnected 혹은 폐쇠망에 저장소가 구축이 안되어 있으면 사용이 불가능.

```bash
dnf provides httpd
dnf install httpd
dnf remove httpd
dnf update 
```

### 종합문제(사용자/그룹/저장소/패키지)

완료하시면 화면에, __"done-lab"__ 이라고 챗팅창에 남겨 주세요.

1. 로그인 가능하다.         == 쉘 사용이 가능.
2. 시스템 접근이 불가능하다. == 쉘 사용이 불가능.

- 사용자 www-hacker, www-user, data-user 그리고 db-user를 생성한다.
- 모든 사용자는 비밀번호를 rockylinuxworld라고 설정한다.
- 사용자 www-hacker는 웹 서비스(httpd)에 접근은 가능하나, 시스템에 접근은 불가능하다.
  - apache라는 그룹에 포함이 된다.
  - www-hacker는 반드시 보조그룹으로 apache에 가입된다.
- www-user,data-user는 secure-data그룹에 포함이 된다.
  - 각 사용자는 tcsh를 통해서 시스템에 접근이 가능하다.
  - 그룹 secure-data가 없는 경우, 사용이 가능하도록 생성한다.
  - GID번호를 13000번으로 설정한다.
- db-user는 wheel그룹에 포함이 되며, 시스템에 로그인이 가능하다.
- 각각 사용자를 ssh로 접근 후 "id"명령어 실행한다.
- 패키지 vsftpd를 설치한다.

- node2에 저장소를 추가한다.
  - "http://172.24.48.199/rpms/"으로 사용하도록 설정한다. 저장소 이름은 "node1"으로 한다.
  - 기존 저장소 파일은 전부 제거한다.
  - 다만, 저장소 미러링 하지 않는 경우, 기존 저장소 파일 제거하지 않는다.
  - 추가된 저장소가 잘 보이는지 'dnf repolist'로 확인한다.
  - 올바르게 구성이 되었으면 httpd패키지를 설치한다.

```bash
www-hacker, rockylinuxworld, www-user, nologin
www-user, rockylinuxworld, secure-data
data-user, rockylinuxworld, secure-data
db-user, rockylinuxworld, wheel

node1

firewall-cmd --add-serivce=http

```



```bash
                   .---> passwd 
                  /
              -----------
adduser  ---> /etc/passwd--. 
                           \
                            @ <----- usermod -aG
                           /
groupadd ---> /etc/group--' 
              ----------
                 \
                  '---> groupmod

whereis nologin     ## false
```

## SELINUX/CRONTAB

1. SELinux(MAC): 커널수준에서 시스템 콜 접근 제어.
2. chmod/chown(DAC): 명시된 영역(사용자 혹은 퍼미션)으로 접근 제어.

이전에는 레드햇 계열만 사용하다가, 현재 모든 리눅스 배포판에서 사용하고 있음. NIST(미국)에서 지원하는 보안 솔루션 중 하나.

현재 오픈 소스에는 두 가지 MAC보안 모델 프로그램이 제공되고 있음.

- AppArmor, GNU
- SELinux, NSA -> OpenSource

현재 사용중인 리눅스에서 SELinux동작 상태 확인. 아래 명령어는 임시적으로 사용하는 명령어.
```bash
getenforce
> 1: enforcing
> 0: permissive
setenforce 0
```

영구적으로 SELinux적용 상태를 변경하기 위해서는 다음과 같이 명령어를 사용해야 됨.

1. /etc/sysconfig/selinux
2. /etc/selinux/config(default)

```bash
ls -l /etc/selinux/
> config
vi /etc/selinux/config
> SELINUX=enforcing  
> SELINUX=permissive
systemctl daemon-reload             ## systemd에 변경내용 반영 요청
dracut -f                           ## 램 디스크 강제 갱신
```

```bash
setenforce 0
vi /etc/selinux/config
> SELINUX=permissive
systemctl daemon-reload

```

"SELINUXTYPE="에 사용하는 옵션은 다음과 같다.

1. targeted: 기본적으로 프로세스 기반으로 모니터링.
2. mls: 다중보안 사용. 보통 수준별 접근이 필요한 경우 사용. NIST에 명시가 되어 있음.
3. minimum: 컨테이너 시스템과 같이 제한적으로 접근 제한이 필요한 경우.



아래와 같이 포트변경 작업을 수행한다.(node2)

```bash
dnf install httpd-core httpd -y 
dnf provides semanage                                             ## 해당 명령어가 어떤 패키지에 포함이 되어 있는지 검색
dnf install policycoreutils-python-utils

semanage port -l | grep http 
> http_cache_port_t              tcp      8080, 8118, 8123, 10001-10010                                                        
> http_cache_port_t              udp      3130                                                                                 
> http_port_t                    tcp      80, 81, 443, 488, 8008, 8009, 8443, 9000                                             pegasus_http_port_t            tcp      5988                                                                                
> pegasus_https_port_t           tcp      5989   

semanage port -a -t http_port_t -p tcp 8841                       ## 변경된 포트 
semanage port -lC                                                 ## 포트 리스트 확인 

systemctl start httpd
systemctl is-active httpd
systemctl is-active firewall                                      ## 방화벽 동작 여부
firewall-cmd --add-port=8841/tcp
firewall-cmd --runtime-to-permanent                               ## 방화벽에 등록된 포트번호를 영구적으로 적용
echo "welcome to NODE2 Server" > /var/www/html/index.html
curl localhost:8841
```


```bash
ls -lZ
ps -efZ
ss -antpZ

grep -Ev '^#|^$' /etc/selinux/config                              ## 주석 및 빈줄 제거
SELINUX=enforcing  --> permissive
reboot
SELINUX=permissive  --> enforcing
SELINUXTYPE=targeted

getenforce
vi /etc/selinux/config  
SELINUX=permissive  --> enforcing                                 ## 영구적용, 리붓팅해야 적용
setenfoce 1                                                       ## 일시적으로 정책 변경 및 적용, 런타임. 1: 적용(on), 0: 미적용(off)
dnf install httpd -y                                              ## Listen 80/TCP
sed -i 's/Listen 80/Listen 8841/g' /etc/httpd/conf/httpd.conf     ## semanage port -l | grep httpd
                                                                  ## dnf install policycoreutils-python-utils
vi /etc/httpd/conf/httpd.conf
grep -i ^Listen /etc/httpd/conf/httpd.conf
Listen 80 ---> 8841
systemctl start httpd                                             ## SELinux에서 port가 위배가 되기 때문에 실행이 중지
                                                                  ## semanage port -l | grep http_
systemctl is-active httpd


## 준비사항

## ------------------------------------------------------------

## 적용사항

dnf provides semanage                                             ## 해당 명령어가 어떤 패키지에 포함이 되어 있는지 검색
dnf install policycoreutils-python-utils
man semanage-port                                                 ## 맨페이지 맨끝에 설명 나와 있음
semanage port -a -t http_port_t -p tcp 8841                       ## 변경된 포트 
semanage port -lC                                                 ## 포트 리스트 확인 
                                                                  ## -l: 리스트의 약자
                                                                  ## -C: 수정된 내용만 출력
semanage port -l | grep http_                                     ## 전체 포트 목록 조회
systemctl is-active httpd
systemctl restart httpd
curl localhost:8841
firewall-cmd --add-port=8841/tcp
firewall-cmd --runtime-to-permanent
echo "Hello Apache" > /var/www/html/index.html
외부> curl이나 웹 브라우저로 8841포트에 접근
```

연습문제
---

1. node2에 httpd서비스 설치 후 포트를 변경
2. SELinux를 permissive로 영구적으로 변경
3. semanage명령어가 없는 경우, 올바르게 동작하도록 패키지 설치
4. 포트번호는 8842/tcp로 http_port_t에 등록
5. /var/www/html/index.html파일에서 "Hello Httpd Node2"메세지 출력
6. 이 페이지는 반드시 외부에서 접근이 가능해야 됨
7. 서비스는 리부팅 이후에도 반드시 시작 및 부트업이 되어야 함.
  1. systemctl enable --now httpd


crontab
---

- at
- crontab
- anacron(지금은 crontab으로 통합)
- systemd-timer

at명령어는 일시적으로 작업을 예약.

anacron도구는 작업 예약 도구. anacron는 이전에 실행이 되지 않은 작업이 있으면, 해당 작업을 실행

crontab도구는 예약된 작업을 특정 시간 및 날짜에 실행.

특정시간에 작업을 수행하는게 주요 목적. 앞으로는 어쩌면, RHEL 9이후로는 crontab를 사용하지 않음.
systemd-timer, .timer를 통해서 특정 시간에 작업 예약이 가능. 이미 기존에 사용하던 anacrontab은 timer로 이동함.

```bash
systemctl -t timer 
```

아직까지는 대다수 서비스는 crontab기반으로 구성 및 설정.
"-u"옵션이 설정이 되어 있지 않으면, 기본적으로 root로 출력 및 편집.

* 모든 분 혹은 모든 시간에 실행

```bash

cat /etc/crontab                                         ## 정책 파일

*/1: 같은 동작, 권장은 "매 X분마다 실행" 

1 * * * *: 1시 1분, 2시 1분, 3시 1분.....
"*/1 * * * *": 1시 1분, 1시 2분, 1시 3분...... 
```

```bash

## 매 1분마다 Hello Node1를 출력하라.
## 사용자 user3에게 작업을 할당.

# -e: edit의 약자, 특정 사용자의 작업 등록 및 편집
# -l: list의 약자, 특정 사용자의 작업 목록 출력
# -u: user의 약자, 사용자 지정

crontab -e -u user3                                      ## 특정 사용자에게 작업 등록
crontab -l -u user3                                      ## 특정 사용자에게 등록된 작업 내용

## 작업 확인 하는 방법, 최소 1분 기다려야 됨.

journalctl -u crond -p info -fl
## 혹은   
tail -f /var/log/cron                                    ## 사용자 작업 파일

crontab -e -u <USERNAME>
crontab -l -u <USERNAME>

ls -l /var/spool/cron/<USERNAME>
```

연습문제(node1)
---
사용자 user4,5에 다음과 같은 메세지를 매 10분마다 출력되게 한다.
"Hello hacker world this is 10 10 messages"


grep
---

특정한 문자열을 포함하거나 혹은 시작과 끝 문자열을 검색한다. 많이 사용하는 옵션은 -R과 -i가 있다.

```bash
grep -Ri GNU /usr/share/doc/ > /root/gnu_words.txt

## 대소문자 상관 없이 검색 -i
## 하위 디렉터리까지 검색 -R
```

연습문제(node1)
---
/usr/share/doc에서 license라는 대문자 단어만 찾아서 /root/materials/license.txt파일에 저장한다.
> grep LICENSE -R /usr/share/doc/ > /root/materials/license.txt


# DAY2

## 압축

tar: 여러 파일을 묶기 기능
xz: 현재 대다수 리눅스 배포판은 .xz으로 압축파일 표준. 라이센스 프리.
gzip: GNU 라이센스 기반의 압축
bzip2: GNU라이센스는 아니지만, 거의 비슷한 라이센스.

```bash
## dnf install xz gzip bzip2

## tar cf --> <NAME>.tar --> xz <NAME>.tar --> <NAME>.tar.xz == tar cfJ <NAME>.tar.xz <TARGET>
## ------                    -------------
##  묶기                          압축

## file <ARCHIVE_NAME>.tar.xz 


## tar -cvf{Z/z/J/j}묶기가 완료가 된 다음에 압축을 수행
##   - j: bzip
##   - J: xz
##   - z: gzip 
##   - Z: compressed(X)

## v: 옵션을 압축혹은 풀기 과정에서 사용하면 CPU사용율이 상승.

## tar cvfz backup.tar.gz -C / /usr/share/doc/   [X]
## tar cvfz /root/backup.tar.gz /usr/share/doc/  [=]
## tar cvfz backup.tar.gz -P /usr/share/doc/ ---> tar cfz backup.tar /usr/share/doc/    [O]
##          ----------       --------------
##          압축파일            압축대상

## tar: Removing leading `/' from member names 아래 링크 참조
## https://unix.stackexchange.com/questions/59243/tar-removing-leading-from-member-names

tar xvzf backup.tar.gz -C /tmp/restore/
    -zxvf          

## --extract: GNU 옵션
## -e: BSD 옵션


tar cf docs.tar /usr/share/doc           ## 묶기
file docs.tar                            ## 압축
bzip2 docs.tar.bz2
file docs.tar.bz2
```

연습문제
---
다음 디렉터리를 압축해서 /tmp에 보관.
- /usr/share/doc, bzip, doc.tar.bz2
- /usr/local, xz, local.tar.xz
- /var/log, gzip, log.tar.gz

## 파일 및 디렉터리 검색 + 쉘 스크립트

스크립트 find
---

```bash
nano search.sh
#/bin/bash
find / -atime +1 -size +1M -type f -print -exec cp -a /tmp/latest_access_files/ {} \; 
```

```bash
## stat <파일경로> 
stat /usr/libexec/grubby/rpm-sort
  File: /usr/libexec/grubby/rpm-sort
  Size: 15736           Blocks: 32         IO Block: 4096   regular file
Device: fd00h/64768d    Inode: 67322266    Links: 1
Access: (0755/-rwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)
Context: system_u:object_r:bin_t:s0
Access: 2023-05-15 11:00:02.925008563 +0900 <-- 이 부분이 -atime(access time) 기록
Modify: 2022-11-02 08:09:40.000000000 +0900
Change: 2023-05-15 10:59:13.740214202 +0900
 Birth: 2023-05-15 10:59:13.740214202 +0900

``` 

CLI find
---
-mtime: 파일 변경 시간 조건.
__-atime:__ 파일 접근 시간 조건.
__-user:__ 사용자 이름.
__-type:__ 자원 형식. file=f, directory=d, link=l
__-perm:__ 퍼미션 유형. 0700,rwx.
__-exec:__ find에서 나온 출력 결과물을(stdout) 다른 명령에서 표준입력(stdin)으로 실행.
__-size:__ 특정 크기의 파일을 검색.


-nouser: 사용자가 지정이 안된 파일.

-nogroup: 그룹이 지정이 안된 파일.

```bash
find / -nouser -nogroup           ## 사용자 및 그룹이 선언이 안되어 있는 파일
```


```bash
mkdir -p /tmp/wrongfiles/

find / -user user1 -type f -print                                                   ## -print는 생략

touch /usr/share/doc/user1.txt
chown -Rf user1. /usr/share/doc/user1.txt

find / -user user1 -type f -exec cp -a {} /tmp/user1_backup \;
                                       --

                    .---------------------------->      /home/user1/.bash_profile x 10
                   /          표준출력                  -------------------------
                  /                                                  |
  ---------------------------------                                  v
{ find / -user user1    -type   f   }     -perm 644    -exec cp -a {   } /tmp/wrongfiles/ \; x 10
               -----           ---              ---                -----               --
               사용자         자원형식                              치환              명령어 끝
```

연습문제
---
- /tmp/user1, user2, user3, user4, user5 백업 디렉터리 생성
- 각각 사용자가 사용하고 있는 모든 파일 및 디렉터리를 각각 백업 디렉터리에 복사
- 복사된 백업 디렉터리 내용은 xz로 압축
- 스크립트 파일 이름을 backup_user.sh으로 생성.
  + 이 스크립트는 사용자 user5를 백업한다.
  + 백업 위치는 /opt/backup-user/user5


## 네트워크 설정(dhcp to static)

호스트이름 변경
---

1. 이전에는 /etc/HOSTNAME파일이나 혹은 /etc/sysconfig/networks에서 "HOSTNAME="값을 변경.
2. 현재는, 표준 방식으로 다시 변경.(유닉스 표준은 /etc/hostname에 저장)
3. systemd에서는 호스트 이름 변경을 'hostnamectl'으로 권장

```bash
hostnamectl set-hostname lab1.example.com    ## 호스트 이름 변경
hostname                                     ## 호스트 이름 확인
hostnamectl
```

네트워크 구성
---

1. 네트워크 작업은 가급적이면 SSH에서 하시지 마시고, 직접 VM CONSOLE에서 직접 작업.
2. 작업이 완료가 되면 무조건 리부팅 후 접근이 가능한지 패키지 다운로드가 가능한지 확인

작업 시 사용이 가능한 도구

- nm-connection-editor(GUI)
- nmtui(TUI)
- nmcli(CLI)

현재 컴퓨터의 아이피 주소 및 라우트(게이트웨이)주소 확인

```bash
ip link                                     ## 현재 서버의 네트워크 장치 확인
ip addr show  ---> ip a s                   ## 장치 아이피 주소 확인
ip r          ---> ip route / route         ## 라우팅 주소 확인
```

```bash
ip link
> eth0

hostnamectl set-hostname lab1.example.com

## 기존거 내용 삭제후 제구성


## 프로파일 추가 방법
nmtui
-->Set system hostname
-->Edit a connection
  -->Delete                                 ## 기존 내용 삭제 후 진행
  -->Add
    -->Ethernet
      = name: eth0-test
      = device: eth0
      = CONFIGURATION: manual
      = address: 192.168.90.0/24
--> active connection (X)                   ## 사용하여도 문제 없지만, 가급적이면 리부팅 권장
reboot

## 기존 내용 기반으로 사용
nmtui
-->Set system hostname
--> Edit a connection       ## eth0, eth1 선택 후
  --> Edit
    --> IPv4
      --> CONFIGURATION: manual
        = address: <IP/CIDR>
        = gateway: <GW IP>
        = dns server: <DNS IP>
-> hostname
reboot

## dhcp에서 static으로 변경 확인 방법

nmcli con show eth0 
## nmcli co sh eth0
> ipv4.method:                            manual
ping <IP>
```

서버 아이피를 GUI기반으로 설정 및 변경을 원하시는 경우.

```bash
@node1#] dnf groupinstall "Server with GUI" -y
@node1#] startx
> nm-connection-editor

@desktop#] ssh -X root@node1 nm-connection-editor
@node1#] reboot
```
CLI기반으로 아이피 추가 혹은 변경 방법

```bash
## 프로파일 추가, 기존에 사용 혹은 생성이 된 프로파일은 삭제
mmcli con sh
nmcli con del ens0

## CLI기반으로 프로파일 생성 후 아이피 설정
nmcli con add type ethernet ifname eth1 con-name eth1 ipv4.addresses 192.168.10.2/24 ipv4.gateway 192.168.10.1 ipv4.dns 192.168.10.250 ipv4.method manual
                                   ----          ----                                                                                              ------
                                   \             \                                                                                                 DHCP -> STATIC
                                    \             `---> 프로파일 이름
                                     \
                                      `---> 실제 장치 이름
## 기존 내용을 수정
# mod: modify
# add: add
# con: connection
# sh: show
# del: delete

## CLI기반으로 프로파일 수정 및 아이피 설정
nmcli con mod con-name eth1 ipv4.addresses 192.168.10.10/24 ipv4.gateway 192.168.10.1 ipv4.dns 192.168.10.250 ipv4.method manual
nmcli con down/up
nmcli con sh eth1
reboot
```

연습문제
---
- 노드1/노드2 가상머신 네트워크 장치 추가(하이퍼브이에서는 eth1)
- 아이피 주소는 192.168.50.12으로 추가
- 넷 마스크는 255.255.255.0으로 설정
- 게이트웨이는 192.168.50.1
- 도메인 정보는 192.168.50.1
- 리부팅 이후에도 정보는 계속 남아 있어야 됨

__연습문제 완료 후 반드시 nmcli con down eth1 해주세요!__

## 소유권 및 퍼미션

<pre>
chmod

0       1       2      3      4      5     6     7  = 8진수(case문으로 구성됨)
        x       w     wx      r     rx    rw    rwx

- chmod 744 <FILE>   1. 사용은 가능하지만, 비권장. 8진수로 하는 경우 숫자 계산이 필요
- chmod u+rwx <FILE> 2. GNU에서는 이 방식으로 사용을 매우 권장

chown
- chown tang.     <FILE> 3. "4번"과 동일한 효과
- chown tang:tang <FILE>  == chown tang.
                          == chown tang.grp
</pre>

__심볼릭__

|값|이름   |
|--|-------|
|u | user  |
|g | group |
|o | other |
|a | all   |
|X | 디렉터리만 적용  |


| 값  | 이름      | 설명 |
|-----|-----------|------|
| u+s | bit key   | 디렉터리 및 실행파일에 적용, 프로그램이 실행할때 소유권자로 실행 --s                  | 
| g+s | bit key   | 디렉터리에 적용. 적용된 디렉터리 밑으로 파일이나 디렉터리는 그룹권한 상속. --g        |
| o+t | stick key | 디렉터리에 누구나 생성이 가능하나, 자신이 생성한 파일이나 혹은 디렉터리 제거 가능 --t |

|기호|설명         |
|----|-------------|
|+   | 퍼미션 추가 |
|=   | 퍼미션 대응 |
|-   | 퍼미션 제거 |

__MAC:__ SELinux and Mandatory Access Control (MAC)
  - selinux
  - apparmor
__DAC:__ discretionary access controls (DAC)
  - chown
  - chmod
__ACL:__ Access Control List (ACL)
  - setfacl/getfact

[mac/dac 차이점](https://www.twingate.com/blog/other/access-control-models)

```bash
chmod u+x   , g+r  , o=       <FILE OR DIR>
      u-w
      u=rwx

chmod -Rf u=rwX --> 모든 파일에는 실행 권한 할당하지 않음
                    실행 파일 및 디렉터리만 권한 유지
```      

o+t(1000): 스틱키(sticky)는 chmod명령어로 선언가능.
  - o+t, o+s는 잘못된 값이지만, 시스템에서는 오류로 표시가 안됨(echo $?)
  - 모든 사용자가 특정 디렉터리에서 파일 및 디렉터리 생성
  - 다른 유저는 자신이 만든 파일이나 디렉터리 제외하고 제거 불가능
           
1. user bitkey에 대표적인 예제는 'sudo'
2. sticky의 대표적인 예제는 "/tmp/"디렉터리

```bash
groupadd sharedir                     ## 이 그룹에만 읽기/쓰기 허용
mkdir /sharedir
chgrp sharedir /sharedir              ## chown :sharedir /sharedir
usermod -aG sharedir user1

## 특정 그룹에게만 파일 생성을 가능하도록 한다. 
chmod g=rwx,g+s /sharedir
mkdir user1.dir                       ## sharedir그룹으로 상속
touch test1.md

## 모든 사용자가 생성이 가능. 자신이 만든 자원 삭제가능
chmod a=rwx,o+t /allsharedir
su - user3
touch user3.md                        ## 자신의 소유권 및 그룹으로 파일생성
mkdir user3.dir
```

```bash
setfacl -m u:user1:rwx /aclsharedir/        ## rwx 가능
setfacl -m u:user5:- /aclsharedir/          ## rwx 불가능
setfacl -m g:sharedir:rwx /aclsharedir/     ## rwx 가능     ==  chmod g+s

su - user1
tocuh /aclsharedir/user1.md
mkdir /aclsharedir/user1.dir

su - user5
touch /aclsharedir/user5.md
touch /aclsharedir/user5.dir

getfacl /sharedir/
```
연습문제
---
- 사용자 user5는 /poweracl/ 디렉터리 접근이 가능하다.
- 사용자 user7는 /poweracl/ 디렉터리에 접근이 불가능하다.
- 이외 모든 사용자는 /poweracl/ 접근이 불가능하다.
- 사용자 user2는 /groupbit/ 디렉터리에 읽기쓰기가 가능하다.
- 사용자 user1는 /groupbit/ 디렉터리에 읽기쓰기가 가능하다.
- /groupbit/ 디렉터리에 접근이 가능한 사용자들은 반드시 groupbit에 가입이 되어 있어야 한다.
- /groupbit/ 디렉터리에서 생성이 되는 파일 및 디렉터리는 반드시 그룹 권한이 상속이 되어야 한다.
- /allbit/ 디렉터리에는 모든 사용자가 파일 생성이 가능하지만, 자신이 만든 파일만 제거가 가능하다.



## rpm 저장소 미러 및 설정

__yum__
  - RHEL 8까지 사용하던 패키지 관리자.
  - yellowdog package update manager
  - 파이선 기반으로 작성됨
__dnf__ RHEL 9부터 사용하는 패키지 관리자.
  - 기존 yum과 호환성 유지
  - module 기능 추가
__microdnf__
  - 컨테이너 이미지 생성시 많이 사용함. 혹은 기본 기능이 필요한 경우 사용


- dnf, yum의 저장소 정보 위치는, "/etc/yum.repos.d/".
- yum설정 파일은 "/etc/yum.conf", "/etc/yum/".
- dnf로 변경이 되면서 해당 파일은 "/etc/dnf.conf", "/etc/dnf/"으로 변경.
- RHEL 9, Rocky 9, CentOS-9-Stream를 사용하는 경우 __dnf__ 가 기본 사용

```bash
dnf install yum-utils -y                                        ## 선택사항

yum-config-manager --add-repo http://localhost/9/appstream/     ## 이전 명령어
dnf config-manager --add-repo=http://localhost/9/appstream/     ## 현재 명령어

rpmkeys --import http://localhost/9/appstream/                  ## 선택사항, gpgcheck를 원하시면 반드시 gpg키를 rpmdb에 등록해야 됨

dnf clean all
dnf search httpd
dnf install httpd                                               ## 설치가 안됨
cat <<EOF>> localhost_9_appstream_.repo
gpgcheck=0                                                      ## gpgcheck 안하도록 설정
EOF

cat localhost_9_appstream_.repo
[localhost_9_appstream_]
name=created by dnf config-manager from http://localhost/9/appstream/
baseurl=http://localhost/9/appstream/
enabled=1
gpgcheck=0

cd /etc/yum.repos.d/
ls -l
```

연습문제
---
- node2의 /etc/yum.repos.d/의 모든 파일을 제거
- 저장소 파일을 아래 주소로 구성
    + https://mirror.kakao.com/linux/rocky/9.1/AppStream/x86_64/os/
- 구성이 완료가 되면, httpd패키지 검색 및 설치 

## ntp

ntp서버 동기화를 설정. 현재는 두 가지 방식으로 NTP서버와 동기화를 지원.

- systemd-timesyncd 서비스(앞으로는 이 기반으로 NTP Client구성)
- chrony client 서비스(systemctl status chronyd)
- 구성을 위한 timedatectl명령어
- NTP 클라이언트 설정 파일은 /etc/chrony.conf


```bash
systemctl stop chronyd
systemctl is-active chronyd
systemctl status chronyd
```

```bash
timedatectl

dnf search chrony
dnf install chrony
systemctl status chronyd
vi /etc/chrony.conf
# pool 2.rocky.pool.ntp.org iburst
server 0.kr.pool.ntp.org iburst          ## NTP와 통신이 가능한 상태면 빠르게 ntp동기화
systemctl restart chronyd
timedatectl set-ntp true
chronyc sources
MS Name/IP address         Stratum Poll Reach LastRx Last sample
===============================================================================
^* 121.162.54.1                  3   6    77    43   -115us[-2324us] +/-   32ms
```
연습문제
---
- node1, node2의 ntp서버를 아래서버로 구성한다.
    + asia.pool.ntp.org
- ntp서비스는 재부팅 이후에도 동작이 되어야한다.


# DAY 3

## 암호 설정

루트 암호를 분실 하였을때.

이전에는 usb나 혹은 cdrom부팅으로 응급복구

ramdisk기반으로 부팅(특히, systemd)
  - initramfs
  - 기본적인 부팅 프로그램 및 자원
  - 루트 암호나 혹은 시스템에 문제가 발생 하였을때 수정하는 방법

```bash
vi /etc/fstab
nano /etc/fstab                                                                     ## /, /home 주석처리

#/dev/mapper/rl_node1-root /                       xfs     defaults        0 0
#/dev/mapper/rl_node1-home /home                   xfs     defaults        0 0
echo skjdhskjhdjkrhieuyrei | passwd --stdin root
dracut -f
reboot

bootloader --> 방향키로 인트럽트 --> e --> linux으로 커서 이동 --> rd.break --> ctrl + x --> shell(ramdisk) --> mount | grep sysroot(ro/ReadOnly) --> mount -oremount,rw /sysroot --> mount | grep sysroot(rw/ReadWrite) --> chroot /sysroot/ --> echo rocky | passwd --stdin root --> vi /etc/fstab --> touch /.autorelabel, SELinux 확장 속성 재구성 --> exit --> exit(reboot)
```

1. /.autorelabel: 이 파일이 존재하면 디스크의 존재하는 SELinux Context를 다시 재구성
2. mount -oremount,rw
3. chroot /sysroot
4. linux, linux16에 맨 끝에 rd.break 추가 후 부트로더 부팅 진행

연습문제
---
- 정상적인 fstab파일에 /, /home를 주석처리
- root 계정의 비밀번호 임으로 변경
- 위의 두 가지 조건을 수행 후, 리부팅 후 root 및 fstab복구 수행

## 스왑

실제 물리적 메모리가 부족하면, 디스크에 메모리 페이지 영역(physcial memory page or RSS)를 파일 시스템으로 그대로 복사한다. 다만, 디스크로 복사되는 메모리 데이터의 조건이 있는데, 다음과 같다.

1. 프로그램에서 접근이 낮은 메모리 데이터
2. 사용율이 현저히 낮거나 혹은 특정한 이유로 사용하지 않지만, 메모리에 남아 있는 데이터

스왑을 생성하는 방법은 세가지 방법이 있다.

1. [X] 파일형태의 스왑
2. [X] LVM2 논리적 장치 스왑
3. [X] 블록 장치 스왑

```bash
swapon -s | swapon                                            ## 스왑 활성화 혹은 상태 확인
swapoff                                                       ## 스왑을 비활성화
mkswap                                                        ## 스왑 시그네처 생성
## 파일기반 스왑 생성

dd if=/dev/zero of=swap.data bs=1G count=1
file swap.data
mkswap /root/swap.data
ls -lh swap.data
chmod 0600 swap.data
swapon swap.data
swapon -s
swapoff /root/swap.data
swapon -s

## 블록장치 스왑
## fdisk, gdisk 여러분이 편한데로 상황에 맞게(mbr/gpt) 사용하세요.
## fidsk, gdisk --> cfdisk
lsblk                     
cfdisk /dev/sdb           ## 100메가짜리 스왑 파티션 생성
> NEW --> 100M
> /dev/sdb1, 파티션 타입은 SWAP으로 변경
> TYPE --> sdb1 --> Linux Filesystem --> Linux Swap
> write
lsblk
mkswap /dev/sdb1          ## read swap header failed 메세지가 발생하면, 해당 명령어가 실행이 안됨.
swapon -s
swapon /dev/sdb1
swapon -s
swapoff /dev/sdb1
vi /etc/fstab
                                 .---> mkswap
                                /
/dev/sdb1       swap         swap         defaults        0      0
---------      ------       -----         --------       ---    ---
장치이름      마운트위치   파일시스템    마운트 옵션    

swapon -s
swapon -a
systemctl daemon-reload
reboot

## LVM2 기반으로 스왑

```

## LVM2


| 명령어 | 설명   |
|--------|--------|
|pvcreate(pv)|물리적 장치 시그네처 생성. 보통 PV라고 이야기함 |
|vgcreate(vg)|볼륨그룹 장치 생성. 1개 이상의 PV를 VG가 가지고 있음 |
|lvcreate(lv)    |논리적 장치 생성. 최종적으로 사용자가 생성하는 장치 |

PV: Physical Volume

VG: Volume Group

LV: Logical Volume

순서대로 명령어를 사용하면 아래와 같이 사용해야 됨.

1. pvcreate
2. vgcreate
3. lvcreate

일반적으로, 이 순서로 장치 구성 및 생성. 

1. vgcreate
2. lvcreate

LVM2를 구성하기 위해서 가급적으면 사용할 파티션 생성 후, LVM2를 구성을 권장.

간단하게 LVM2에 새로운 디스크를 생성한다.

```bash
cfdisk /dev/sdb
> /dev/sdb2                  ## 새로 파티션 하나 생성. 모든 공간 사용
> 파티션 형식으로 Linux LVM로 변경
lsblk
fdisk -l
pvcreate /dev/sdb2           ## PV로 사용하겠다고 싸인표시
pvs
vgcreate vgtest /dev/sdb2    ## /dev/sdb2의 PV를 VG에 사용 선언
vgs
lvcreate -n lvtest00    -l   100%Free       vgtest
            --------         --------      --------
            디스크 이름         \           VG이름
                                 \
                                  `--> 모든 PE(extend)개수를 다 사용
lvs
lvdisplay
> /dev/vgtest/lvtest00
mkfs.xfs /dev/vgtest/lvtest00               ## 파일 시스템 생성(슈퍼블럭), VFS에서 마운트를 못함
mkdir -p /mnt/test
mount /dev/vgtest/lvtest00 /mnt/test

df
> /dev/mapper/vgtest-lvtest00  10369024 105404       580 1% /mnt/test
umount /mnt/test

mkdir -p /mnt/lvtest00
vi /etc/fstab
> /dev/vgtest/lvtest00   /mnt/lvtest00    xfs     defaults 0 0
mount -a
df
> /dev/mapper/vgtest-lvtest00  10369024 105404       580 1% /mnt/lvtest00

systemctl daemon-reload
dracut -f

dd if=/dev/zero of=/mnt/lvtest00/dummy.data bs=1G 
>dd: error writing '/mnt/lvtest00/dummy.data': No space left on device
>10+0 records in
>9+0 records out
>10509352960 bytes (11 GB, 9.8 GiB) copied, 31.636 s, 332 MB/s

## 명령어 요약
cfdisk | fdisk | gdisk 
pvcreate /dev/sdb2
vgcreate /dev/sdb2 hellovg
lvcreate -l 100%Free -n hellolv hellovg
## -t: 
## -L: 디스크 크기
## -l: 익스텐드(extend) 개수
```

- pvs, vgs, lvs: 간단하게 PV상태 확인
- pv/vg/lvdisplay: 자세하게 PV상태확인

### lvm2기반으로 swap생성

```bash
cfdisk /dev/sdc
> 1G 파티션 생성
> 타입은 LVM으로 변경
pvcreate /dev/sdc1
vgcreate testswap /dev/sdc1 
lvcreate -n lvswap -L 500M testswap

mkswap /dev/testswap/lvswap
vi /etc/fstab
/dev/testswap/lvswap     swap    swap   defaults  0   0
swapon -a
swapon -s
reboot
```

### LVM2 리사이즈

특정 VG 및 LV 디스크 공간이 부족할때 사용.

```bash
vgs
>VG       #PV #LV #SN Attr   VSize    VFree
>rl         1   3   0 wz--n-  125.41g      0
>testswap   1   1   0 wz--n- 1020.00m 520.00m
>vgtest     1   1   0 wz--n-   <9.90g      0

fdisk /dev/sdc
>2기가 파티션 추가 생성
>LVM파티션으로 수정

# pvcreate /dev/sdc2
vgextend vgtest /dev/sdc2
vgs                                           ## Free영역이 늘어 났는지 확인
# cp -a /usr/share/doc /mnt/lvtest00          ## 테스트 명령어
> No space left on device 
lvdisplay
lvextend -r -L +500M /dev/vgtest/lvtest00     ## -r옵션은 파일시스템도 자동으로 확장
df
reboot

xfs_growfs /mnt/lvtest00
resize2fs /dev/testvg/testlv 

```

### PE크기 변경 및 LVM 생성

```bash
fdisk /dev/sdd
> 3기가 파티션
> LVM으로 형식 변경
fdisk -l /dev/sdd
vgcreate -s 4m  resizevg /dev/sdd1
         -s 16m
vgdisplay resizevg
> PE Size               16.00 MiB
lvcreate -l 50 -n resizeinglv resizevg
mkfs.ext4 /dev/resizevg/resizeinglv
vi /etc/fstab
>/dev/resizevg/resizeinglv   /mnt/ext4    ext4    defaults 0 0
mount -a
```

### Stratis

XFS기반으로 Pool기능을 구현. XFS에서는 Pool기능이 없어서, Stratis기반으로 Pool기반의 Filesystem를 구성. 상대적으로 LVM2보다 가볍고 편하게 디스크 관리가 가능.

만약, XFS의 Stratis 파일 시스템 풀링 싫으면, btrfs의 네이티브 파일 시스템 풀링 기능을 사용하여도 됨. 하지만, RHEL계열의 배포판에서는 대다수가 btrfs를 지원 안함.

- xfs, pool(x)
- btrfs, pool
- zfs, Oracle (x)
- jfs, IBM AIX (x)

```bash
cfdisk /dev/sdd
> 3G기가 파티션
> 리눅스 파일 시스템
fdisk -l /dev/sdd
> /dev/sdd2  6293504 12584959 6291456   3G Linux filesystem
dnf search stratis
dnf install stratisd stratis-cli -y
systemctl enable --now stratisd
stratis pool list
stratis pool create pool1 /dev/sdd2
stratis filesystem create pool1 xfs_disk
mkdir -p /mnt/test
mount /dev/stratis/pool1/xfs_disk /mnt/test
blkid
> /dev/mapper/stratis-1-709d22ce20b14e67aaf31779e00357b3-thin-fs-ccbcbf2b9942479cbc4cec628b8f9084: UUID="ccbcbf2b-9942-479c-bc4c-ec628b8f9084" TYPE="xfs"
```

VG에서 PV제거하기(제외)

```bash
vgdisplay testvg
pvs
> PV가 어떤 VG에 포함이 되어 있는지
vgremove /dev/sdb2 testvg           ## testvg에서 sdb2 PV를 제거
vgs
pvs
vgextend vgtest /dev/sdb2
```


연습문제
---
지식확인 문제

## 스토리지

디스크 /dev/sdb에 다음처럼 파티션을 구성 및 생성한다.
  - 1기가 크기의 스왑 파티션을 생성한다.
  - 1기가 크기의 LVM디스크를 생성한다.
  - 불륨그룹의 이름은 testvg이며, 논리디스크 이름은 testlv이다.
    + 디스크 크기는 testvg 영역을 전부 사용한다.
  - 해당 디스크는 반드시 /mnt/testlv에 연결 및 구성이 되어야한다.
    + dd if=/dev/zero of=/mnt/testlv/dummy.data count=1 bs=1G 실행
  - 스왑 및 디스크 리부팅 이후에도 정상적으로 연결 및 동작이 되어야 한다.

LVM기반으로 스왑 디스크를 생성한다.
  - SWAP크기는 2기가 이며, LVM에 lvswap이름으로 논리 디스크를 구성한다.
  - 해당 스왑은 testvg영역에서 생성이 된다.
  - 리부팅 이후에도 정상적으로 연결 및 동작이 되어야 한다.

볼륨그룹 공간 확장
  - /mnt/testlv에 공간이 부족한 경우, 공간을 확장한다. 
  - 확장 시, 사용하는 공간 크기는 5기가를 사용한다.
  - 기존 파일 시스템에 손상이 없이 파일 시스템을 확장한다.
  - 리부팅 이후에도 정상적으로 연결 및 동작이 되어야 한다.

새로운 LVM디스크를 구성한다.
  - 익스텐드 크기는 8메가로 구성한다.
  - 새로운 디스크의 이름은 extendlv으로 구성한다.
  - 불륨 그룹 이름은 extendvg로 구성한다.
  - 리부팅 이후에도 정상적으로 연결 및 동작이 되어야 한다.

Pool 파일 시스템을 구성한다.
  - 디스크 전체를 Pool로 구성한다.
  - Pool의 이름은 pool-storage으로 한다.
  - 파일 시스템 이름은 data-filesystem으로 설정한다
  - 리부팅 이후에도 정상적으로 연결 및 동작이 되어야 한다.

### container

docker는 더 이상 사용하지 않음. docker가 미란티스라는 회사에 인수가 된 이후, 개발 방향을 변경.

docker는 도커 하위 계층인 containerd를 분리. 현재 쿠버네티스 및 CNCF 표준 런타임. 
쿠버네티스는 CRI표준 기반의 CRI-O런타임 사용. containerd, cri-docker를 사용할 수 도 있음.

학습 시, 권장하는 방법은 docker가 아닌, podman기반으로 학습. 기존 도커에서 사용하던 명령어 및 컨테이너 이미지 파일은 현재 OCI사양에서 표준 이미지 및 명령어로 채택. 현재 레드햇 리눅스 및 다른 상용 배포판 그리고 커뮤니티 배포판은 docker가 아닌 podman으로 권장. 

- podman
- buildah
- skopeo

systemd에서는 컨테이너 기반으로 서비스 혹은 애플리케이션을 실행 할 수 있음. 

podman.service: API 서비스 대몬

```bash
dnf search podman
dnf install podman -y
adduser containeruser
echo rocky | passwd --stdin containeruser
ssh containeruser@localhost
cu$> podman login -u <ID> -p <PASSWD> <URL>      ## 로그인 단계
cu$> podman search httpd                           ## 이미지 검색
cu$> podman pull quay.io/centos7/httpd-24-centos7:latest
cu$> podman run -d -p8080:8080 --name container-web quay.io/centos7/httpd-24-centos7:latest
## -p: 외부포트:컨테이너 포트
## -d: deatach, 백-그라운드 실행
## --name: 컨테이너가 생성시 사용하는 이름
cu$> podman stop --all       ## 모든 컨테이너 동작 중지
cu$> podman rm --all          ## 모든 컨테이너 삭제
cu$> podman ps
cu$> curl localhost:8080
cu$> podman generate systemd --new --files --name container-web
cu$> man -k podman-
cu$> man podman-generate-systemd               ## 무조건 맨 페이지 참고
      --> Installation of generated systemd unit files.
cu$> mkdir -p ~/.config/systemd/user
cu$> cp container-container-web.service ~/.config/systemd/user
cu$> systemctl daemon-reload --user
cu$> systemctl enable --now container-web --user
root#> loginctl enable-linger containeruser
cu$> systemctl status container-web --user
cu$> curl localhost:8080
```
 
```bash

## 사용자 containeruser에서 진행

wget https://raw.githubusercontent.com/tangt64/training_memos/main/opensource/linux-101/materials/Containerfile

## Dockerfile에서 현재는 Containerfile로 변경.

podman build . -t web-container
buildah bud -f <FILENAME>          ## dnf install buildah, 선택사항 :)
podman images
mkdir htdocs/
echo "hello systemd service container" > htdocs/index.html

## -Z: SELinux Context 상속 옵션

podman run -d --name new-web-container -v /home/containeruser/htdocs/:/var/www/html/:Z -p 8081:80 localhost/web-container
curl http://localhost:8081
>hello systemd service container
```

연습문제
---
- 컨테이너 이미지를 빌드한다. 컨테이너 파일은 github에서 내려받기한다.
- 이미지 이름은 hello-www으로 명명한다.
- 컨테이너가 실행이 되면 포트, 8082로 접근이 되어야 한다. 
  + 만약, 접근이 안되는 경우 트러블 슈팅을 진행한다. 
- 컨테이너는 htdocs2디렉터리에 있는 index.html파일에 접근이 가능해야 한다.
  + index.html파일에서는 "hello www service"라는 텍스트를 가지고 있어야 한다.
  + /var/www/html/으로 바인딩이 되어야 한다. 
- 구성된 컨테이너는 systemd기반으로 서비스 구성한다.
  + 리부팅 이후에도 정상적으로 동작이 되어야 됨.
  + 사용자가 로그아웃을 하여도 서비스는 계속 동작이 되어야 됨. 


### tuned

__커널 파라메타__ 를 프로파일 기반으로자 동으로 조절 해주는 도구. 

```bash
dnf install tuned -y

systemctl enable --now tuned
tuned-adm profile

tuned-adm profile desktop            ## 수동으로 변경
tuned-adm active                     ## 현재 사용중인 프로파일 확인
tuned-adm recommend                  ## 알아서 프로파일 선택
tuend-adm auto_profile
```

연습문제
---
- 프로파일 AWS 프로파일로 변경한다.
- tuned에서 권장하는 프로파일를 사용한다.

### autofs

특정 디렉터리를 NFS와 같은 공유 파일 시스템을 통해서 자동적으로 연결 및 구성.

1. 최소 NFS서버나 혹은 samba서버가 있어야 됨.
2. 클라이언트 서버에는 autofs설치가 가능해야 함. 


서버(node1)
---

```bash
dnf install nfs-utils
systemctl enable --now nfs-server
setenforce 0
mkdir -p /srv/nfs/nfs-user1
mkdir -p /srv/nfs/nfs-user2
mkdir -p /srv/nfs/direct-user
ls -l /etc/exports
vi /etc/exports
/srv/nfs/direct-user *(rw,sync)      ## 다이렉트
/srv/nfs/nfs-user1   *(rw,sync)      ## 다이렉트 
/srv/nfs/nfs-user2   *(rw,sync)      ## 다이렉트
/srv/nfs/            *(rw,sync)      ## 인-다이렉트
exportfs -avrs
systemctl stop firewalld
```

클라이언트(node2)
---

```bash
dnf install nfs-utils -y
adduser -M nfs-user1                ## 사용자 홈 디렉터리 생성하지 않음.
adduser -M nfs-user2

## -------------------------

showmount -e 192.168.122.247        ## 서버 아이피, node1번 아이피 입력 해주세요.
exporting *:/srv/nfs
exporting *:/srv/nfs/nfs-user2
exporting *:/srv/nfs/nfs-user1

dnf install autofs -y
cd /etc/auto.master.d/

## in-direct 구성

vi mappinguser.autofs
/home/               /etc/auto.mappinguser

vi /etc/auto.mappinguser
*       -rw,sync       192.168.122.247:/srv/nfs/&
systemctl restart autofs

## direct 구성
vi direct.autofs
/-               /etc/auto.direct
vi /etc/auto.direct
/home/direct-user       -rw,sync       192.168.122.247:/srv/nfs/direct-user


terminal2] journalctl -lf -u autofs.service
```

연습문제
---


# 메모
- 특정 그룹에 어떤 사용자가 포함이 되어 있는지?
  - grep wheel 
  - 이는 'lid'명령어로 확인이 가능
- SELINUX/CRONTAB

## 옵션 설명, firewalld

__runtime-to-permanent:__ 현재 firewalld에 등록되어 있는 정책 내용을 그대로 디스크에 영구적으로 저장. 리부팅 이후에도 다시 재적용.
__permanent:__ "--permanent"옵션이 들어간 "firewall-cmd"정책만 디스크에 영구적으로 저장.