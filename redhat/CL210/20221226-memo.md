# day 1

**강사이름:** 최국현
**메일주소:** bluehelix@gmail.com


**화이트 보드**
(https://wbd.ms/share/v2/aHR0cHM6Ly93aGl0ZWJvYXJkLm1pY3Jvc29mdC5jb20vYXBpL3YxLjAvd2hpdGVib2FyZHMvcmVkZWVtL2ZmODkwODFkZTJjMDRhOGY5ZDdmZWJhYWVkM2ZjYmYzX0JCQTcxNzYyLTEyRTAtNDJFMS1CMzI0LTVCMTMxRjQyNEUzRF8xMzI3Y2FmZi05NTQ1LTQwZGUtYjM1Mi02YTIyMGVhNmMxYjc=)

**메모 주소**
(https://github.com/tangt64/training_memos/blob/main/redhat/CL210/20221226-memo.md)


**점심시간**: 12시부터 1시 20분까지
**쉬는시간**: 15분

## 강의 진행전 준비작업

1. gnome-tweaks
```bash
sudo yum install gnome-tweaks
gnome-tweaks 
```


"heat", "ansible"의 차이 및 공통점
1. YAML사용한다는 부분에서 공통점
2. ansible은 모듈 기반 작업
3. 워크플로우, 변수 값 위주의 작업
4. heat는 사양에 따라서 동작 및 작업을 수행

heat는 기본적으로 YAML기반으로, 렌더링(파싱)후 컴파일 및 실행을 한다.

**OpenStack Heat**: https://wiki.openstack.org/wiki/Heat

### undercloud network

1. dhcp ---> dnsmasq(dhcp, dns)             
   ----
   \
    '---> 구성시 사용하는 "A"레코드 생성
2. tft
3. pxeboot

"OVS"는 리눅스 브릿지와 함께 사용이 되고 있으며, OV는(은) 기존 리눅스 브릿지를 랩핑을 하고 있음.
```bash
ip -br a        ## ovs + linux bridge compoment 
ovs-vsctl show
ovs-vsctl br-list  ## ovs bridge list
                   ## ovs정보는 ovsdb에서 가져와서 출력

```

```
      .----------------------------.
     /   rabbitmq[message]          \
+--------+                       +--------+
| cinder |  --- (snap=image)---> | glance | 
+--------+					     +--------+
    APP                               APP
          RPC(Remote Program Call)
```

## day 2

### docker vs podman

"openstack kolla"는 아직 docker를 사용하고 있음. 
>docker는 containerd로 분리 및 변경
>기존 도커는 더 이상 사용하지 않음
>docker ---> cri-dockerd변경됨
>docker ---> podman 전환 
>레드햇 RHOSP경우에는 podman를 기반으로 되어 있음. 

**podman기반으로 docker호환성 유지**

```bash
yum install podman podman-docker epel-release
yum install docker-compose
```
**정리**
RHOSP는 docker대신 podman를 사용하고 있음.
커뮤니티 경우에는 아직 docker기반으로 사용.
CRI표준을 따름.(이미지 및 명령어).
conmon이 컨테이너 모니터링, runc가 컨테이너 실행


0. podman, buildah, skopeo(from docker functions)
  - search
  - build
  - run
  
1. CRI표준 방식으로 동작하는 경우 어떤구조?
  - podman으로 일반적으로 컨테이너 실행
      + standalone 형식 
      + CRI standard 사용
          * docker image는 현재 산업 표준
          * docker command도 현재 산업 표준
  - conmon기반으로 컨테이너 실행
      + 이전에는 docker == container
          * docker -> dockerd -> containerd -> shim
          * 이 구조는 너무 복잡함
      + 현재는 container == runtime*
          * runc, crun, kata...
      + podman에서 사용하는 데몬(daemon) API서버 역할만 하기 때문에 사용하지 않음
      + 쿠버네티스, cri-docker, podman, crio, containerd를 사용해도 "conmon"기반으로 동작
      + conmon은, container monitoring 모니터링
          * runc가 현재 사용중이 런타임
          * podman, docker, crio(kubernetes)
              - 공통적으로 사용하는 실제 런타임은 "runc"
 
2. podman어떤역할을 해주는가?
  - container, pod, volume, network같은 정보를 관리

3. openstack kolla 이미지 
  - dumb-init 기반으로 동작(init, signal control)
  - rootstate 권한을 더 많이 가지고 있음
      + linux capabilities(EffectiveCaps, RHOSP Kolla는 일반 컨테이너와 다른 권한을 더 가지고 있음)
      + namespace(mnt)
      + 컨테이너에서 사용하는 설정 파일은 바인딩이 되어 있음
          * podman inspect
          * mount -obind 
          * namespace <mnt>자원을 통해서 다시 컨테이너로 전달
          
4. rootless vs rootstate(ful) 컨테이너
  - kolla vs normal container


### 추가 설명 할 부분(내일 아침에 추가 설명)

- podman 구성 및 구조
  * 오픈스택에서 어떤식으로 사용하는지?
  * 기존과 차이점?

- rabbitmq dashboard에서 topic, queue
